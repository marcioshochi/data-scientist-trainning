# # dplyr vs. SQL

# Copyright © 2010–2018 Cloudera. All rights reserved.
# Not to be reproduced or shared without prior written 
# consent from Cloudera.

# Which is easier to write: dplyr or SQL?

# When asking simple questions of your data, SQL queries
# are often easy to write and understand. But when asking
# more complex questions, SQL queries can become much more
# difficult to write and understand.

# To illustrate this, use the iris flower example near the
# beginning of the dplyr verbs module. This example
# calculates the rounded average sepal width 
# of iris flowers by species after removing some outlying 
# values, and returns the results in increasing order:

iris_spark <- sdf_copy_to(spark, iris)

avg_sepal_width_spark <- iris_spark %>%
  select(Sepal_Width, Species) %>%
  filter(Sepal_Width > 2.0 & Sepal_Width < 4.0) %>%
  group_by(Species) %>%
  summarise(Avg_Sepal_Width = mean(Sepal_Width)) %>%
  arrange(Avg_Sepal_Width) %>%
  mutate(Avg_Sepal_Width = round(Avg_Sepal_Width, 1))

avg_sepal_width_spark

# sparklyr (with dplyr and dbplyr) calculated the above result
# by translating the series of verbs into a SQL statement.

# To see the SQL statement, use `show_query()`:

avg_sepal_width_spark %>% show_query()

# (Note that SQL statements generated by dplyr backends 
# sometimes contain unnecessary subqueries.)

# If you prefer to directly write and issue SQL queries, 
# you could obtain this same result by issuing the following
# command:

tbl(spark, sql("SELECT Species, round(avg(Sepal_Width), 1) AS Avg_Sepal_Width 
FROM iris 
WHERE Sepal_Width > 2.0 AND Sepal_Width < 4.0
GROUP BY 
Species ORDER BY Avg_Sepal_Width"))

# R users typically find it more intuitive to use dplyr verbs
# instead of directly writing SQL statements.

# A chain of dplyr verbs can be read left to right and top 
# to bottom, whereas complex nested SQL statements need to 
# be read from the inside out, starting with the most deeply 
# nested subqueries and working your way out.
